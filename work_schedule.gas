function ShiftAutomation() {
  // ⭐️変数の定義
  const ss = SpreadsheetApp.getActiveSpreadsheet();  //スプレッドシートアプリを呼び出して、現在のスプレッドシートファイルを取得

  //[シート]スタッフ名簿
  const staffRegister = ss.getSheetByName("スタッフ名簿"); //スタッフ名簿シートを取得
  //スタッフ名簿の値を取得
  const staffsData = staffRegister.getRange(2, 1, staffRegister.getLastRow() - 1, staffRegister.getLastColumn()).getValues();
  //カラムの定義
  const staffCols = staffRegister.getRange(1, 1, 1, staffRegister.getLastColumn()).getValues().flat();
  const jobCol = staffCols.indexOf("職種");
  const nurseJob = "看護師"
  const employeeTypeCol = staffCols.indexOf("雇用形態");
  const namecol = staffCols.indexOf("氏名");
  const nurses = staffsData.filter(row => row[jobCol] == nurseJob);//看護師名簿
  const others = staffsData.filter(row => row[jobCol] != nurseJob);//看護師以外名簿

  //[シート]希望休
  const dayOffSheet = ss.getSheetByName("希望休入力カレンダー"); //現場が入力するシートを取得
  const shiftYear = dayOffSheet.getRange(1, 1).getValue(); //希望休カレンダーにある　年　を取得
  const shiftMonth = dayOffSheet.getRange(1, 6).getValue();//希望休カレンダーにある　月　を取得
  const eoMonth = new Date(shiftYear, shiftMonth, 0).getDate();     //希望休カレンダーにある　月末日　を取得

  //[シート]勤務条件設定
  const workSettingSheet = ss.getSheetByName("勤務設定");
  const settingRowDatas = workSettingSheet.getRange(1, 1, workSettingSheet.getLastRow(), 1).getValues().flat();
  const requiredDayStaffsRow = settingRowDatas.indexOf("日勤スタッフ数");
  const requiredDayStaffs = workSettingSheet.getRange(requiredDayStaffsRow + 1, 2).getValue();
  const requiredNightStaffsRow = settingRowDatas.indexOf("夜勤スタッフ数");
  const requiredNightStaffs = workSettingSheet.getRange(requiredNightStaffsRow + 1, 2).getValue();
  const number0fDayNursesRow = settingRowDatas.indexOf("日勤看護師最低人数");
  const requiredDayNurses = workSettingSheet.getRange(number0fDayNursesRow + 1, 2).getValue();
  const number0fNightNursesRow = settingRowDatas.indexOf("夜勤看護師最低人数");
  const requiredNightNurses = workSettingSheet.getRange(number0fNightNursesRow + 1, 2).getValue();
  const continuousWorkRow = settingRowDatas.indexOf("連勤上限");
  const continuousWork = workSettingSheet.getRange(continuousWorkRow + 1, 2).getValue();
  const monthlyDayOffRow = settingRowDatas.indexOf("月間休暇日数");
  const monthlyDayOff = workSettingSheet.getRange(monthlyDayOffRow + 1, 2).getValue();
  const nightShiftIntervalRow = settingRowDatas.indexOf("夜勤最短間隔"); //連勤上限
  const nightShiftInterval = workSettingSheet.getRange(nightShiftIntervalRow + 1, 2).getValue();

  //[シート]雇用形態
  const onlyDayShift = "日勤専従"
  const onlyNightShift = "夜勤専従"

  //[シート]シフト名
  const nikkin = "日";
  const yakin = "夜";
  const ake = "明";
  const kibokyu = "希";
  const yukyu = "有";
  const kakikyu = "夏";
  const toukikyu = "冬";
  const yasumi = "休";
  const akeyasu = "明休"
  const workday = [nikkin, yakin];
  const dayOff = [yasumi, kibokyu];
  const asatteyasumi = [null, kibokyu];

  //ランダムメソッドで使う直近１週間勤務数に応じた配列
  const probablityShift = [100, 98, 95, 93, 85, 10, 5];

  //ただのテスト。ちゃんとsetValuesできるか見るため。
  const testSheet = ss.getSheetByName("テスト");
  // testSheet.getRange(1,1,staffsData.length,staffsData[0].length).setValues(staffsData);テストシートで使えるよ

  //⭐️スタッフの勤務表枠をオブジェクトで作成
  const shiftMonthByStaffs = {};//1人ずつ一月分の配列を連想配列にする
  staffsData.forEach(function ([_, name]) { //スタッフ名簿の2つ目のインデックスの値を
    shiftMonthByStaffs[name] = Array(eoMonth).fill(null); //プロパティにして、それぞれ、月の日数分値を用意してnullを入れる
  }); //log {清水咲良:[null, null, null,...],鈴木翔太:[null, null, null,...],...} 


  //⭐️希望休を入れる
  const reqDayOff = {};
  //希望休シートにあるスタッフを一次元配列に
  const dayOffStaffs = dayOffSheet.getRange(6, 1, dayOffSheet.getLastRow() - 5, 1).getValues().flat();
  //希望休の二次元配列
  const dayOffDatas = dayOffSheet.getRange(6, 3, dayOffStaffs.length, eoMonth).getValues();
  for (i = 0; i < dayOffStaffs.length; i++) {
    reqDayOff[dayOffStaffs[i]] = dayOffDatas[i]; //名前をプロパティ、日にちを値とする連想配列に
  };
  for (name in reqDayOff) {//スタッフシフトの連想配列 と 希望休の連想配列 のループ
    const daysOff = reqDayOff[name];
    const shiftMonthByStaffsArr = shiftMonthByStaffs[name];
    //希望休カレンダーに何か入力されていたら、休日扱いにする
    for (let i = 0; i < daysOff.length; i++) {
      if (daysOff[i] != "") shiftMonthByStaffsArr[i] = daysOff[i];
    };
  };// shiftMonthByStaffs = {清水咲良:[null, "休", null,...],鈴木翔太:["休", null, null,...],...} 

  //⭐️⭐️日毎にシフトを作成する
  for (let day = 0; day < eoMonth; day++) {//該当月の1日から月末日まで
    const nextDay = day + 1;
    const next2Day = day + 2;
    const prevDay = day - 1;
    const prev2Day = day - 2;
    //休日数をカウントして配列にする
    const dayOffThisMonth = Object.entries(shiftMonthByStaffs)//オブジェクトを配列に
      .map(([name, values]) => {  //名前と休日数の要素に
        const countDayOff = values.filter(v => dayOff.includes(v)).length;
        return [name, countDayOff];
      })//[[吉田莉子, 0.0], [佐藤健太, 2.0], ...]
    //関数：スタッフ名簿の配列に休日数をpushした配列　→　休日数が多いスタッフ順にする
    function DayOffSort(job) {
      for (let i = 0; i < job.length; i++) {
        const a = job[i][namecol];//スタッフ名簿　の氏名
        for (let j = 0; j < dayOffThisMonth.length; j++) {
          const b = dayOffThisMonth[j][0];//休日数の配列にある　氏名
          const bCount = dayOffThisMonth[j][1];//休日数
          if (day == 0) {  //最初だけ”休日数”の要素を追加してあとは　”休日数”を更新していく
            if (a == b) job[i].push(bCount);
          } else {
            if (a == b) job[i][job[0].length - 1] = bCount;
          };
        };
      };
      job.sort(() => Math.random() - 0.5)//ランダムにして
        .sort((a, b) => b[job[0].length - 1] - a[job[0].length - 1]);//休日数が多い順にする
      return job;
    };
    const sortedNurses = DayOffSort(nurses);
    const sortedOthers = DayOffSort(others);

    //日勤に必要なスタッフを休日数多い順して看護師、それ以外で並べる
    const dayNurses = sortedNurses.slice(0, requiredDayNurses); //看護師が必要な分
    //[看護師以外,requiredDayNursesから漏れた看護師]を休日数多い順に
    const leftOverDaystaffs = DayOffSort([...sortedOthers, ...sortedNurses.slice(requiredDayNurses)]);
    //"必要な看護師"と"それ以外のスタッフ"に並び替え
    const shuffledDayStaffs = [...dayNurses, ...leftOverDaystaffs];

    //夜勤も同様
    const nightNurses = sortedNurses.slice(0, requiredNightNurses);
    const leftOverNightstaffs = DayOffSort([...sortedOthers, ...sortedNurses.slice(requiredNightNurses)]);
    const shuffledNightStaffs = [...nightNurses, ...leftOverNightstaffs];

    //夜勤を検討
    //シャッフルしたスタッフの配列の"名前"と"雇用形態"をループ
    for (let [, name, , , , , , , job, type] of shuffledNightStaffs) {//[]の中は"スタッフ名簿"シートの順番に則る
      const shift = shiftMonthByStaffs[name];
      //夜勤の現在人数を数える
      const numberOfNightStaffs = Object.values(shiftMonthByStaffs).filter(row => row[day] == yakin).length;
      //夜勤の現在の　看護師以外　の人数を数える
      const number0fNightOthers = staffsData.filter(staff => {
        const staffName = staff[namecol];
        const staffjob = staff[jobCol];
        return staffjob != nurseJob && shiftMonthByStaffs[staffName][day] == yakin;
      }).length;
      //夜勤の現在の　看護師　の人数を数える
      const number0fNightnurses = staffsData.filter(staff => {
        const staffName = staff[namecol];
        const staffjob = staff[jobCol];
        return staffjob == nurseJob && shiftMonthByStaffs[staffName][day] == yakin;
      }).length;
      //必要人数に達していたらbreak
      if (numberOfNightStaffs >= requiredNightStaffs) break;
      //看護師　と　看護師以外　の人数が規定数配置されていたらcontinue
      if (job == nurseJob && number0fNightnurses >= requiredNightNurses) continue;
      if (job != nurseJob && number0fNightOthers >= requiredNightStaffs - requiredNightNurses) continue;

      if (shift[day]) continue;  //その日[day]にnull以外が入っていたらcontinue
      if (type == onlyDayShift) continue; //雇用形態が日勤専従ならcontinue
      const prevDay1shift = day > 0 ? shift[prevDay] : null; //前日のシフト
      const prevDay2shift = day > 1 ? shift[prev2Day] : null; //前々日のシフト
      if ([prevDay1shift, prevDay2shift].includes(yakin)) continue; //前日と前々日に夜勤が含まれていたらcontinue

      //直近の夜勤シフト
      const forNightShiftInterval = shift.slice(Math.max(0, day - nightShiftInterval), day)
      //直近の夜勤回数
      const nightShiftIntervalLength = forNightShiftInterval.filter(work => yakin.includes(work)).length
      //指定の期間に夜勤があればcontinue
      if (nightShiftIntervalLength >= 1) continue;
      //直近の「連勤上限」日数分の勤務str
      const recentDay = shift.slice(Math.max(0, day - continuousWork), day);
      //そのうちの日勤の数
      const recentWorkConut = recentDay.filter(v => v == nikkin).length;
      //連勤上限に達していたらcontinue
      if (day > 0 && recentWorkConut == continuousWork) continue;
      //今月の　日勤と夜勤の数を抽出
      const workedThisMonth = shift.filter(work => workday.includes(work)).length;//
      //公休を規定日数に達しているならcontinue
      if (workedThisMonth >= eoMonth - monthlyDayOff) continue;

      //直近１週間の勤務回数が多いほど休みになりやすい
      // if (Math.random() * 100 < probablityShift[workedThisWeek]) {
      if (next2Day < eoMonth) {
        if (shift[nextDay] == null && asatteyasumi.includes(shift[next2Day])) {
          shift[day] = yakin;//上記の条件(明日、明後日が休日)をクリアした人に夜勤を入れる
          shift[nextDay] = ake;//夜勤に翌日は明け
          shift[next2Day] = akeyasu;//明けの次の日は必ず休みになる
        };
      } else if (next2Day == eoMonth) {
        if (shift[nextDay] == null) {
          shift[day] = yakin;
          shift[nextDay] = ake;//夜勤に翌日は明け
        };
      } else {
        shift[day] = yakin;
      }
      // };
    };

    //日勤を検討   夜勤との違いは翌日、翌々日に勤務情報を入れなくもよいところ。
    for (let [, name, , , , , , , job, type] of shuffledDayStaffs) {
      const shift = shiftMonthByStaffs[name];
      const numberOfDayStaffs = Object.values(shiftMonthByStaffs).filter(row => row[day] == nikkin).length;
      const number0fDayOthers = staffsData.filter(staff => {
        const staffName = staff[namecol];
        const staffjob = staff[jobCol];
        return staffjob != nurseJob && shiftMonthByStaffs[staffName][day] == nikkin;
      }).length;
      const number0fDaynurses = staffsData.filter(staff => {
        const staffName = staff[namecol];
        const staffjob = staff[jobCol];
        return staffjob == nurseJob && shiftMonthByStaffs[staffName][day] == nikkin;
      }).length;
      if (numberOfDayStaffs >= requiredDayStaffs) break;
      if (job == nurseJob && number0fDaynurses >= requiredDayNurses) continue;
      if (job != nurseJob && number0fDayOthers >= requiredDayStaffs - requiredDayNurses) continue;
      if (shift[day]) continue;
      if (type == onlyNightShift) continue; //夜勤専従ならcontinue
      const prevDay1 = day > 0 ? shift[prevDay] : null;
      const prevDay2 = day > 1 ? shift[prev2Day] : null;
      if ([prevDay1, prevDay2].includes(yakin)) continue;

      const recentDay = shift.slice(Math.max(0, day - continuousWork), day);
      const recentWorkConut = recentDay.filter(v => v == nikkin).length;
      if (day > 0 && recentWorkConut == continuousWork) continue;
      const workedThisMonth = shift.filter(work => workday.includes(work)).length;
      if (workedThisMonth >= eoMonth - monthlyDayOff) continue;
      // if (Math.random() * 100 < probablityShift[workedThisWeek]) {
      shift[day] = nikkin;
      // };
    };
    //ここで勤務が当てはまらなかった人は"休"とする
    for (let name in shiftMonthByStaffs) {
      if (shiftMonthByStaffs[name][day] == null) shiftMonthByStaffs[name][day] = yasumi;
    };
  };

  // ‼️作業中‼️　まだ定員に達していない
  //⭐️⭐️定員に達していない日
  for (let name in shiftMonthByStaffs) {
    const shift = shiftMonthByStaffs[name];
    // 現在の休み数を数える
    let currentDaysOff = shift.filter(day => dayOff.includes(day)).length;
    const type = staffsData.filter(col => col[namecol] == name).map(v => v[employeeTypeCol]);
    // 指定の公休数より多い場合
    while (currentDaysOff > monthlyDayOff) {
      // 勤務可能な日（現在"休"になっている日）を探す
      const restIndexes = shift;

      let found = false;
      for (let i = restIndexes.length - 1; i > 0; i--) {
        const day = restIndexes[i];
        if (day != yasumi) continue;//"休"しか検討しない
        const recentDay = shift.slice(Math.max(0, day - continuousWork), day);//直近の「連勤上限」日数分の勤務str
        const recentWorkConut = recentDay.filter(v => v == nikkin).length;
        if (day > 0 && recentWorkConut == continuousWork) continue;
        // if (!recentDay.some(v => dayOff.includes(v))) continue;//連勤上限に達していたらcontinue;

        const nextDay = day + 1;
        const next2Day = day + 2;

        // その日の勤務人数を数える
        const dayWorkCount = Object.values(shiftMonthByStaffs).filter(row => row[day] == nikkin).length;
        const dayNightCount = Object.values(shiftMonthByStaffs).filter(row => row[day] == yakin).length;

        // 夜勤を検討  夜勤が足りていない & 明け/次の日に勤務がなければ
        if (dayNightCount < requiredNightStaffs) {
          if (type == onlyDayShift) continue;
          // 明け・休みを入れる余裕があるか
          if (next2Day < eoMonth) {
            if (shift[nextDay] == yasumi && dayOff.includes(shift[next2Day])) {
              shift[day] = yakin;
              shift[nextDay] = ake;
              shift[next2Day] = akeyasu;
              currentDaysOff--;
              found = true;
              break;
            };
          } else if (next2Day == eoMonth) {
            if (shift[nextDay] == yasumi) {
              shift[day] = yakin;
              shift[nextDay] = ake;
              currentDaysOff--;
              found = true;
              break;
            };
          } else {
            shift[day] = yakin;
            currentDaysOff--;
            found = true;
            break;
          };
        };

        //日勤検討　まだ日勤人数が足りていないなら
        if (dayWorkCount < requiredDayStaffs) {
          if (type == onlyNightShift) continue;
          if (shift[day] == yasumi) shift[day] = nikkin;
          currentDaysOff--;
          found = true;
          break;
        }
      }

      // 適した勤務日がなければ break（無限ループ防止）
      if (!found) break;
    }
  }

  //⭐️⭐️



  //⭐️スプレッドシートに転記
  //スプレッドシートに吐き出せる様に二次元配列に直す
  const testArray = Object.entries(shiftMonthByStaffs).map(([name, shift]) => [name, ...shift]);
  //スプレッドシートに転記
  testSheet.clear();
  testSheet.getRange(1, 1, testArray.length, testArray[0].length).setValues(testArray);

};
