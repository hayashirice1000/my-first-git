function TEST() {
  // ⭐️変数の定義
  const ss = SpreadsheetApp.getActiveSpreadsheet();  //スプレッドシートアプリを呼び出して、現在のスプレッドシートファイルを取得
  const staffRegister = ss.getSheetByName("スタッフ名簿"); //スタッフ名簿シートを取得
  const dayOffSheet = ss.getSheetByName("希望休入力カレンダー"); //現場が入力するシートを取得
  const shiftYear = dayOffSheet.getRange(1, 1).getValue(); //希望休カレンダーにある　年　を取得
  const shiftMonth = dayOffSheet.getRange(1, 6).getValue();//希望休カレンダーにある　月　を取得
  const eoMonth = new Date(shiftYear, shiftMonth, 0).getDate();     //希望休カレンダーにある　月末日　を取得
  const testSheet = ss.getSheetByName("テスト"); //ただのテスト。ちゃんとsetValuesできるか見るため。
  // testSheet.getRange(1,1,staffsData.length,staffsData[0].length).setValues(staffsData);テストシートで使えるよ
  const staffsData = staffRegister.getRange(2, 1, staffRegister.getLastRow() - 1, staffRegister.getLastColumn()).getValues();
  const staffColRow = staffRegister.getRange(1, 1, 1, staffRegister.getLastColumn()).getValues();//スタッフ名簿のスタッフを取得
  const staffCol = staffColRow[0];//上段のを一次元配列にする
  const nurses = staffsData.filter(row => row[8] == "看護師");//看護師名簿
  const others = staffsData.filter(row => row[8] != "看護師");//看護師以外名簿
  const number0fDayNurses = 2; //日勤　看護師　必要人数
  const requiredDayStaffs = 6; //日勤　必要人数
  const number0fNightNurses = 1; //夜勤　看護師　必要人数
  const requiredNightStaffs = 2 //夜勤　　必要人数


  //⭐️スタッフの勤務表枠をオブジェクトで作成
  const shiftMonthByStaffs = {};//1人ずつ一月分の配列を連想配列にする
  staffsData.forEach(function ([_, name]) { //スタッフ名簿の2つ目のインデックスの値を
    shiftMonthByStaffs[name] = Array(eoMonth).fill(null); //プロパティにして、それぞれ、月の日数分値を用意してnullを入れる
  }); //log {清水咲良:[null, null, null,...],鈴木翔太:[null, null, null,...],...} 

  //⭐️希望休を入れる
  const reqDayOff = {};
  //希望休シートにあるスタッフを一次元配列に
  const dayOffStaffs = dayOffSheet.getRange(6, 1, dayOffSheet.getLastRow() - 5, 1).getValues().flat();
  const dayOffDatas = dayOffSheet.getRange(6, 3, dayOffStaffs.length, eoMonth).getValues();//希望休の二次元配列
  for (i = 0; i < dayOffStaffs.length; i++) {
    reqDayOff[dayOffStaffs[i]] = dayOffDatas[i]; //名前をプロパティ、日にちを値とする連想配列に
  };
  for (name in reqDayOff) {
    //for...in文で二つの連想配列の名前が合致する時の操作をできる様にする
    const daysOff = reqDayOff[name];
    const shiftMonthByStaffsArr = shiftMonthByStaffs[name];
    //希望休カレンダーに何か入力されていたら、休日扱いにする
    for (let i = 0; i < daysOff.length; i++) {
      if (daysOff[i] != "") shiftMonthByStaffsArr[i] = "休";
    };
  };// shiftMonthByStaffs = {清水咲良:[null, "休", null,...],鈴木翔太:["休", null, null,...],...} 

  //⭐️日毎にシフトを作成する
  for (let day = 0; day < eoMonth; day++) {//日毎に

    //スタッフをシャッフルする
    //看護師をシャッフル
    const shuffledNurses = nurses.sort(() => Math.random() - 0.5);//看護師全員をシャッフル

    //日勤に必要なスタッフをシャッフルして看護師、それ以外で並べる
    const requiredDayNurses = shuffledNurses.slice(0, number0fDayNurses); //看護師が必要な分
    const leftOverDaystaffs = [...others, ...shuffledNurses.slice(number0fDayNurses)].sort(() => Math.random() - 0.5);
    const shuffledDayStaffs = [...requiredDayNurses, ...leftOverDaystaffs];

    //夜勤も同様
    const requiredNightNurses = shuffledNurses.slice(0, number0fNightNurses); //看護師が必要な分
    const leftOverNightstaffs = [...others, ...shuffledNurses.slice(number0fNightNurses)].sort(() => Math.random() - 0.5);
    const shuffledNightStaffs = [...requiredNightNurses, ...leftOverNightstaffs];
    // Logger.log(shuffledNightStaffs.map(v=>v[1]))


    //夜勤を検討
    //シャッフルしたのスタッフの配列の名前と職種と雇用形態をループ
    for (let [, name, , , , , , , job, type] of shuffledNightStaffs) {
      //夜勤の現在人数を数える
      const numberOfNightStaffs = Object.values(shiftMonthByStaffs).filter(row => row[day] == "夜勤").length;
      if (numberOfNightStaffs >= requiredNightStaffs) break;//必要人数に達していたらbreak
      if (shiftMonthByStaffs[name][day]) continue;  //その日[day]にnull以外が入っていたらcontinue
      if (type == "日勤専従") continue; //日勤専従ならcontinue
      const prevDay1 = day > 0 ? shiftMonthByStaffs[name][day - 1] : null; //前日のシフト
      const prevDay2 = day > 1 ? shiftMonthByStaffs[name][day - 2] : null; //前々日のシフト
      if ([prevDay1, prevDay2].includes("夜勤")) continue; //前日と前々日に夜勤が含まれていたらcontinue

      //6日前から今日までのシフト
      const thisWeek = shiftMonthByStaffs[name].slice(Math.max(0, day - 6), day);
      //日勤と夜勤の数を抽出
      const workedThisWeek = thisWeek.filter(work => work == "日勤" || work == "夜勤").length;
      //今月の　日勤と夜勤の数を抽出
      const workedThisMonth = shiftMonthByStaffs[name].filter(work => work == "日勤" || work == "夜勤").length;//
      //今週6日以上勤務しているか、今月（月日数-9日）以上勤務している）ならcontinue
      if (workedThisWeek >= 5 || workedThisMonth >= eoMonth - 9) continue;

      shiftMonthByStaffs[name][day] = "夜勤";//上記の条件をクリアした人に夜勤を入れる
      if (day + 1 < eoMonth) shiftMonthByStaffs[name][day + 1] = "明け";//夜勤に翌日は明け
      if (day + 2 < eoMonth) shiftMonthByStaffs[name][day + 2] = "休";//明けの次の日は必ず休みになる
    };

    //日勤を検討   夜勤との違いは翌日、翌々日に勤務情報を入れなくもよいところ。
    for (let [, name, , , , , , , job, type] of shuffledDayStaffs) {
      const numberOfDayStaffs = Object.values(shiftMonthByStaffs).filter(row => row[day] == "日勤").length;
      if (numberOfDayStaffs >= requiredDayStaffs) break;
      if (shiftMonthByStaffs[name][day]) continue;
      if (type == "夜勤専従") continue; //夜勤専従ならcontinue
      const prevDay1 = day > 0 ? shiftMonthByStaffs[name][day - 1] : null;
      const prevDay2 = day > 1 ? shiftMonthByStaffs[name][day - 2] : null;
      if ([prevDay1, prevDay2].includes("夜勤")) continue;

      const thisWeek = shiftMonthByStaffs[name].slice(Math.max(0, day - 6), day);
      const workedThisWeek = thisWeek.filter(work => work == "日勤" || work == "夜勤").length;
      const workedThisMonth = shiftMonthByStaffs[name].filter(work => work == "日勤" || work == "夜勤").length;
      //今週6日以上勤務しているか、今月（月日数-9日）以上勤務している）ならcontinue
      if (workedThisWeek >= 6 || workedThisMonth >= eoMonth - 9) continue;

      shiftMonthByStaffs[name][day] = "日勤";
    };
  };

  //‼️作業中‼️
  //nullに”休”を代入
  for (let name in shiftMonthByStaffs) {
    shiftMonthByStaffs[name] = shiftMonthByStaffs[name].map(value => value == null ? "休" : value);
  };
  //スプレッドシートに吐き出せる様に二次元配列に直す
  const testArray = Object.entries(shiftMonthByStaffs).map(([name, shift]) => [name, ...shift]);
  // Logger.log(testArray)
  testSheet.getRange(1, 1, testArray.length, testArray[0].length).setValues(testArray);
};
