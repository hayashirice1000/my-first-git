function ShiftAutomation() {
  // ⭐️変数の定義
  const ss = SpreadsheetApp.getActiveSpreadsheet();  //スプレッドシートアプリを呼び出して、現在のスプレッドシートファイルを取得

  //[シート]スタッフ名簿
  const staffRegister = ss.getSheetByName("スタッフ名簿"); //スタッフ名簿シートを取得
  //スタッフ名簿の値を取得
  const staffsData = staffRegister.getRange(2, 1, staffRegister.getLastRow() - 1, staffRegister.getLastColumn()).getValues();
  //カラムの定義
  const staffCols = staffRegister.getRange(1, 1, 1, staffRegister.getLastColumn()).getValues().flat();
  const jobCol = staffCols.indexOf("職種");
  const nurseJob = "看護師"
  const employeeTypeCol = staffCols.indexOf("雇用形態");
  const namecol = staffCols.indexOf("氏名");
  const nurses = staffsData.filter(row => row[jobCol] == nurseJob);//看護師名簿
  const others = staffsData.filter(row => row[jobCol] != nurseJob);//看護師以外名簿

  //[シート]希望休
  const dayOffSheet = ss.getSheetByName("希望休入力カレンダー"); //現場が入力するシートを取得
  const shiftYear = dayOffSheet.getRange(1, 1).getValue(); //希望休カレンダーにある　年　を取得
  const shiftMonth = dayOffSheet.getRange(1, 6).getValue();//希望休カレンダーにある　月　を取得
  const eoMonth = new Date(shiftYear, shiftMonth, 0).getDate();     //希望休カレンダーにある　月末日　を取得

  //[シート]勤務条件設定
  const workSettingSheet = ss.getSheetByName("勤務設定");
  const settingRowDatas = workSettingSheet.getRange(1, 1, workSettingSheet.getLastRow(), 1).getValues().flat();
  const requiredDayStaffsRow = settingRowDatas.indexOf("日勤スタッフ数");
  const requiredDayStaffs = workSettingSheet.getRange(requiredDayStaffsRow + 1, 2).getValue();
  const requiredNightStaffsRow = settingRowDatas.indexOf("夜勤スタッフ数");
  const requiredNightStaffs = workSettingSheet.getRange(requiredNightStaffsRow + 1, 2).getValue();
  const number0fDayNursesRow = settingRowDatas.indexOf("日勤看護師最低人数");
  const requiredDayNurses = workSettingSheet.getRange(number0fDayNursesRow + 1, 2).getValue();
  const number0fNightNursesRow = settingRowDatas.indexOf("夜勤看護師最低人数");
  const requiredNightNurses = workSettingSheet.getRange(number0fNightNursesRow + 1, 2).getValue();
  const continuousWorkRow = settingRowDatas.indexOf("連勤上限");
  const continuousWork = workSettingSheet.getRange(continuousWorkRow + 1, 2).getValue();
  const limitoverWorkDay = continuousWork + 1//連勤上限のループ時使用
  const monthlyDayOffRow = settingRowDatas.indexOf("月間休暇日数");
  const monthlyDayOff = workSettingSheet.getRange(monthlyDayOffRow + 1, 2).getValue();
  const nightShiftIntervalRow = settingRowDatas.indexOf("夜勤最短間隔"); //連勤上限
  const nightShiftInterval = workSettingSheet.getRange(nightShiftIntervalRow + 1, 2).getValue();

  //[シート]雇用形態
  const onlyDayShift = "日勤専従"
  const onlyNightShift = "夜勤専従"

  //[シート]シフト名
  const nikkin = "日";
  const yakin = "夜";
  const ake = "明";
  const kibokyu = "希";
  const yukyu = "有";
  const kakikyu = "夏";
  const toukikyu = "冬";
  const yasumi = "休";
  const akeyasu = "明休"
  const workday = [nikkin, yakin];
  const dayOff = [yasumi, kibokyu, akeyasu];
  const dayOffForYakin = [yasumi, kibokyu];
  const asatteyasumi = [null, kibokyu];

  //ランダムメソッドで使う直近１週間勤務数に応じた配列
  const probablityShift = [100, 98, 95, 93, 85, 10, 5];

  //ただのテスト。ちゃんとsetValuesできるか見るため。
  const testSheet = ss.getSheetByName("テスト");
  // testSheet.getRange(1,1,staffsData.length,staffsData[0].length).setValues(staffsData);テストシートで使えるよ

  //⭐️スタッフの勤務表枠をオブジェクトで作成
  const shiftMonthByStaffs = {};//1人ずつ一月分の配列を連想配列にする
  staffsData.forEach(function ([_, name]) { //スタッフ名簿の2つ目のインデックスの値を
    shiftMonthByStaffs[name] = Array(eoMonth).fill(null); //プロパティにして、それぞれ、月の日数分値を用意してnullを入れる
  }); //log {清水咲良:[null, null, null,...],鈴木翔太:[null, null, null,...],...} 


  //⭐️希望休を入れる
  const reqDayOff = {};
  //希望休シートにあるスタッフを一次元配列に
  const dayOffStaffs = dayOffSheet.getRange(6, 1, dayOffSheet.getLastRow() - 5, 1).getValues().flat();
  //希望休の二次元配列
  const dayOffDatas = dayOffSheet.getRange(6, 3, dayOffStaffs.length, eoMonth).getValues();
  for (i = 0; i < dayOffStaffs.length; i++) {
    reqDayOff[dayOffStaffs[i]] = dayOffDatas[i]; //名前をプロパティ、日にちを値とする連想配列に
  };
  for (name in reqDayOff) {//スタッフシフトの連想配列 と 希望休の連想配列 のループ
    const daysOff = reqDayOff[name];
    const shiftMonthByStaffsArr = shiftMonthByStaffs[name];
    //希望休カレンダーに何か入力されていたら、そのデータを代入する
    for (let i = 0; i < daysOff.length; i++) {
      if (daysOff[i] != "") shiftMonthByStaffsArr[i] = daysOff[i];
    };
  };// shiftMonthByStaffs = {清水咲良:[null, "希", null,...],鈴木翔太:["有", null, null,...],...} 

  //⭐️⭐️日毎にシフトを作成する
  for (let day = 0; day < eoMonth; day++) {//該当月の1日から月末日まで
    const nextDay = day + 1;
    const next2Day = day + 2;
    const prevDay = day - 1;
    const prev2Day = day - 2;
    //休日数をカウントして配列にする
    const dayOffThisMonthArr = Object.entries(shiftMonthByStaffs)//オブジェクトを配列に
      .map(([name, values]) => {  //名前と休日数の要素に
        const countDayOff = values.filter(v => dayOff.includes(v)).length;
        return [name, countDayOff];
      })//[[吉田莉子, 0.0], [佐藤健太, 2.0], ...]
    //関数：スタッフ名簿の配列に休日数をpushした配列　→　休日数が多いスタッフ順にする
    function DayOffSort(job) {
      for (let i = 0; i < job.length; i++) {
        const a = job[i][namecol];//スタッフ名簿　の氏名
        for (let j = 0; j < dayOffThisMonthArr.length; j++) {
          const b = dayOffThisMonthArr[j][0];//休日数の配列にある　氏名
          const bCount = dayOffThisMonthArr[j][1];//休日数
          if (day == 0) {  //最初だけ”休日数”の要素を追加してあとは　”休日数”を更新していく
            if (a == b) job[i].push(bCount);
          } else {
            if (a == b) job[i][job[0].length - 1] = bCount;
          };
        };
      };
      job.sort((a, b) => {
        const diff = b[job[0].length - 1] - a[job[0].length - 1];
        if (diff != 0) return diff;
        return Math.random() - 0.5;
      });
      return job;

    };
    const sortedStaffs = DayOffSort(staffsData);

    //夜勤を検討
    //シャッフルしたスタッフの配列の"名前"と"雇用形態"をループ
    for (let [, name, , , , , , , job, type] of sortedStaffs) {//[]の中は"スタッフ名簿"シートの順番に則る
      const shift = shiftMonthByStaffs[name];
      //夜勤の現在人数を数える
      const numberOfNightStaffs = Object.values(shiftMonthByStaffs).filter(row => row[day] == yakin).length;
      //夜勤の現在の　看護師以外　の人数を数える
      const numberOfNightOthers = staffsData.filter(staff => {
        const staffName = staff[namecol];
        const staffjob = staff[jobCol];
        return staffjob != nurseJob && shiftMonthByStaffs[staffName][day] == yakin;
      }).length;
      //夜勤の現在の　看護師　の人数を数える
      const numberOfNightnurses = staffsData.filter(staff => {
        const staffName = staff[namecol];
        const staffjob = staff[jobCol];
        return staffjob == nurseJob && shiftMonthByStaffs[staffName][day] == yakin;
      }).length;

      //必要人数に達していたらbreak
      if (numberOfNightStaffs >= requiredNightStaffs) break;
      //看護師　と　看護師以外　の人数が規定数配置されていたらcontinue
      if (job == nurseJob && numberOfNightnurses >= requiredNightNurses) continue;
      if (job != nurseJob && numberOfNightOthers >= requiredNightStaffs - requiredNightNurses) continue;

      if (shift[day]) continue;  //その日[day]にnull以外が入っていたらcontinue
      if (type == onlyDayShift) continue; //雇用形態が日勤専従ならcontinue
      const prevDay1shift = day > 0 ? shift[prevDay] : null; //前日のシフト
      const prevDay2shift = day > 1 ? shift[prev2Day] : null; //前々日のシフト
      if ([prevDay1shift, prevDay2shift].includes(yakin)) continue; //前日と前々日に夜勤が含まれていたらcontinue

      //直近の夜勤シフト
      const forNightShiftInterval = shift.slice(Math.max(0, day - nightShiftInterval), day)
      //直近の夜勤回数
      const nightShiftIntervalLength = forNightShiftInterval.filter(work => yakin.includes(work)).length
      //指定の期間に夜勤があればcontinue
      if (nightShiftIntervalLength >= 1) continue;
      //直近の「連勤上限」日数分の勤務str
      const previousDay = shift.slice(Math.max(0, day - continuousWork), day);
      //そのうちの日勤の数
      const previousWorkCount = previousDay.filter(v => v == nikkin).length;
      //連勤上限に達していたらcontinue
      if (day > 0 && previousWorkCount == continuousWork) continue;

      //今月の　休日数を抽出
      const dayOffThisMonth = shift.filter(off => dayOff.includes(off)).length;
      //　😲怪しい!　休日日数達しているならcontinue
      if (name == "松本結衣") Logger.log("day" + day);
      if (name == "松本結衣") Logger.log(name);
      if (name == "松本結衣") Logger.log("休暇数 =" + dayOffThisMonth);
      if (name == "松本結衣") Logger.log(shift.filter(off => dayOff.includes(off)));

      if (dayOffThisMonth == monthlyDayOff) continue;

      if (next2Day < eoMonth) {
        if (shift[nextDay] == null && asatteyasumi.includes(shift[next2Day])) {
          shift[day] = yakin;//上記の条件(明日、明後日が休日)をクリアした人に夜勤を入れる
          shift[nextDay] = ake;//夜勤に翌日は明け
          shift[next2Day] = akeyasu;//明けの次の日は必ず休みになる
        };
      } else if (next2Day == eoMonth) {
        if (shift[nextDay] == null) {
          shift[day] = yakin;
          shift[nextDay] = ake;//夜勤に翌日は明け
        };
      } else {
        shift[day] = yakin;
      }
      // };
    };

    //日勤を検討   夜勤との違いは翌日、翌々日に勤務情報を入れなくもよいところ。
    for (let [, name, , , , , , , job, type] of sortedStaffs) {
      const shift = shiftMonthByStaffs[name];
      const numberOfDayStaffs = Object.values(shiftMonthByStaffs).filter(row => row[day] == nikkin).length;
      const numberOfDayOthers = staffsData.filter(staff => {
        const staffName = staff[namecol];
        const staffjob = staff[jobCol];
        return staffjob != nurseJob && shiftMonthByStaffs[staffName][day] == nikkin;
      }).length;
      const numberOfDaynurses = staffsData.filter(staff => {
        const staffName = staff[namecol];
        const staffjob = staff[jobCol];
        return staffjob == nurseJob && shiftMonthByStaffs[staffName][day] == nikkin;
      }).length;
      if (numberOfDayStaffs >= requiredDayStaffs) break;
      if (job == nurseJob && numberOfDaynurses >= requiredDayNurses) continue;
      if (job != nurseJob && numberOfDayOthers >= requiredDayStaffs - requiredDayNurses) continue;
      if (shift[day]) continue;
      if (type == onlyNightShift) continue; //夜勤専従ならcontinue
      const prevDay1 = day > 0 ? shift[prevDay] : null;
      const prevDay2 = day > 1 ? shift[prev2Day] : null;
      if ([prevDay1, prevDay2].includes(yakin)) continue;

      const previousDay = shift.slice(Math.max(0, day - continuousWork), day);
      const previousWorkCount = previousDay.filter(v => v == nikkin).length;
      if (day > 0 && previousWorkCount == continuousWork) continue;
      const dayOffThisMonth = shift.filter(off => dayOff.includes(off)).length;
      if (dayOffThisMonth == monthlyDayOff) continue;
      shift[day] = nikkin;
      // };
    };
    //ここで勤務が当てはまらなかった人は"休"とする
    for (let name in shiftMonthByStaffs) {
      if (shiftMonthByStaffs[name][day] == null) shiftMonthByStaffs[name][day] = yasumi;
    };
  };

  //⭐️⭐️定員に達していない日
  for (let name in shiftMonthByStaffs) {
    const shift = shiftMonthByStaffs[name];
    // 現在の休み数を数える
    let currentDaysOff = shift.filter(day => dayOff.includes(day)).length;
    // const type = staffsData.filter(col => col[namecol] == name).map(v => v[employeeTypeCol]);
    const type = staffsData.filter(col => col[namecol] == name).flat()[employeeTypeCol];

    // 指定の公休数より多い場合
    while (currentDaysOff > monthlyDayOff) {
      // 勤務可能な日（現在"休"になっている日）を探す

      let found = false;
      for (let day = 0; day < shift.length; day++) {

        if (shift[day] != yasumi) continue;//"休"しか検討しない
        const previousDay = shift.slice(Math.max(0, day - continuousWork), day);//直近の「連勤上限」日数分の勤務str        
        const previousWorkCount = previousDay.filter(work => workday.includes(work)).length;
        if (day > 0 && previousWorkCount == continuousWork) continue;

        const nextDay = day + 1;
        const next2Day = day + 2;
        // その日の勤務人数を数える
        const dayWorkCount = Object.values(shiftMonthByStaffs).filter(row => row[day] == nikkin).length;
        const dayNightCount = Object.values(shiftMonthByStaffs).filter(row => row[day] == yakin).length;

        // 夜勤を検討  夜勤が足りていない & 明け/次の日に勤務がなければ
        if (dayNightCount < requiredNightStaffs) {
          if (type == onlyDayShift) continue;
          // 明け・休みを入れる余裕があるか
          if (next2Day < eoMonth) {
            if (shift[nextDay] == yasumi && dayOffForYakin.includes(shift[next2Day])) {
              shift[day] = yakin;
              shift[nextDay] = ake;
              shift[next2Day] = akeyasu;
              currentDaysOff--;
              found = true;
              break;
            };
          } else if (next2Day == eoMonth) {
            if (shift[nextDay] == yasumi) {
              shift[day] = yakin;
              shift[nextDay] = ake;
              currentDaysOff--;
              found = true;
              break;
            };
          } else {
            shift[day] = yakin;
            currentDaysOff--;
            found = true;
            break;
          };
        };

        //日勤検討　まだ日勤人数が足りていないなら
        if (dayWorkCount < requiredDayStaffs) {
          if (type == onlyNightShift) continue;
          if (shift[day] == yasumi) {
            shift[day] = nikkin;
            currentDaysOff--;
            found = true;
            break;
          };
        }
      };

      // 適した勤務日がなければ break（無限ループ防止）
      if (!found) break;
    }
  }




  //⭐️⭐️もう一度
  for (let name in shiftMonthByStaffs) {

    const shift = shiftMonthByStaffs[name];

    const type = staffsData.filter(col => col[namecol] == name).flat()[employeeTypeCol];
    if (type == onlyNightShift) continue;

    let currentDaysOff = shift.filter(day => dayOff.includes(day)).length;

    while (currentDaysOff > monthlyDayOff) {
      let found = false;
      //月間の勤務者数が少ないランキング（連想配列の配列）
      const workCount = [...Array(eoMonth)].fill(null).map((_, col) => ({
        index: col,
        values: Object.values(shiftMonthByStaffs).map(row => row[col]).filter(v => v == nikkin).length
      })).sort((a, b) => a.values - b.values);


      for (let { index } of workCount) {  //勤務者数少ない日ランキング上位からみていく    

        if (shift[index] == yasumi) {
          shift[index] = nikkin;
          //現在のindex日で以下のfor文で一度でも
          for (let i = 0; i < limitoverWorkDay; i++) {
            const recentDay = shift.slice(
              Math.max(0, index - continuousWork + i),
              Math.min(index + i + 1, eoMonth)
            );

            const recentDayWorkCount = recentDay.filter(work => workday.includes(work)).length;
            if (recentDayWorkCount >= limitoverWorkDay) {
              shift[index] = yasumi;
              break;
            }
          };
          //日勤が入ったので現在の休日数から1日引く
          if (shift[index] == nikkin) {
            currentDaysOff--;
            found = true;
          }
        };
        if (currentDaysOff <= monthlyDayOff) break;
      };
      if (!found) break;
    };
  };

  //⭐️スプレッドシートに転記
  //スプレッドシートに吐き出せる様に二次元配列に直す
  const testArray = Object.entries(shiftMonthByStaffs).map(([name, shift]) => [name, ...shift]);
  //スプレッドシートに転記
  testSheet.clear();
  testSheet.getRange(1, 1, testArray.length, testArray[0].length).setValues(testArray);

};
